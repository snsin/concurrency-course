# Задание 5. Практика: изучаем экзекьюторы в Spring Boot #
1. Реализовал с помощью `@Async("applicationTaskExecutor")` также возможен вариант с указанием
   аннотации у класса (retention policy позволяет). В данном случае в параметрах аннотации можно
   не указывать экзекьютор, т.к. определен единственный бин applicationTaskExecutor.
2. `@Async("applicationTaskExecutor")` + не забыть добавить `@EnableAsync`. Также сделал данный метод
   слушателем событий (`@EventListener`)
3. Задачи запускаются в разных потоках, однако следует помнить, что если вызвать метод напрямую, то 
   метод `AsyncClassTest.internalTask` запустится синхронно, в том же потоке, в котором запустилась 
   задача из метода `AsyncClassTest.runAsyncTask`.
   
   Ниже вывод кода с з`@EventListener`
   ```text
    runAsyncTask: task-1 id: 29
    internalTask: task-2 id: 31
   ```
4. Особенность использования аннотации `@Async` в том, что если она используется с методом,
   реализованным в том же классе, что и вызывающий код и этот код вызывает нужный метод напрямую, 
   то он вызовется синхронно.
   Чтобы данная аннотация работала как задумывалось возможны следующие варианты:
   - сделать целевой метод слушателем событий, а в вызывающем методе, опубликовать нужное событие
   - реализовать целевой метод в другом классе. Такое требование + требование, чтобы данный метод был публичным,
   необходимы для того, чтобы можно было проксировать вызов метода, помеченного аннотацией `@Async`.
   Прокси обернет метод в `Callable` и засабмиттит задачу на выполнение в экзекьютор.
5. Конфигурация по умолчанию следующая
   * емкость очереди - Integer.MAX_VALUE
   * исходное кол-во потоков - 8 (corePoolSize)
   * максимальное кол-во потоков в пуле: Integer.MAX_VALUE
   * можно ли уничтожать простаивающие потоки по истечении времени жизни - да
   * время, жизни простаивающего потока - 60 секунд
   * ждать ли завершения запланированных задач по завершению тред-пула - нет
   * период ожидания завершения запланированных задач - null (не задан) awaitTerminationPeriod
   * префикс имени потока - "task-"
   * кастомайзеры таск-экзекьютора - нет
   * декораторы задач - нет
6. На мой взгляд, значения по умолчанию имеет смысл переопределять в следующих случаях (по убыванию значимости):
   * При большой нагрузке есть риск, что кол-во потоков и очередь вырастут до больших или значений и 
     займут всю память, имеет смысл уменьшать максимальное кол-во потоков в пуле и размер очереди.
     Как гипотетический пример могу привести следующую ситуацию - например, если сервис должен по запросу
     асинхронно взять из БД большое кол-во наборов данных, для каждого набора произвести расчеты и сохранить
     результаты. Если наборов много, то кол-во занятых потоков возрастет, в результате чего, при плохом 
     стечении обстоятельств мы получим OOM. Чтобы этого избежать нужно уменьшить максимальное кол-во потоков
     и ограничить размер очереди.
   * При меняющемся профиле нагрузки, например, когда асинхронные блокирующие задачи чередуются с действиями
     затратными по памяти, имеет смысл уменьшить время жизни потока. Это приведет к более быстрому уничтожению
     простаивающих потоков и освобождению памяти.
   * Если нужно кастомизировать имя потока для более удобного чтения логов, то имеет смысл задать свой 
     узнаваемый префикс.
   * В случае, если нужны более точные мониторинг и логгирование, то стоит добавить свои декораторы задач.
