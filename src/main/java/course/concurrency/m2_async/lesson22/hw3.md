# Задание 5. Практика: изучаем экзекьюторы в Spring Boot #
1. Реализовал с помощью `executor.submit(() -> {...})`
2. `@Async` + не забыть добавить `@EnableAsync`
3. Задачи запускаются не в main потоке, однако метод `AsyncClassTest.internalTask` запускается
   синхронно, в том же потоке, в котором запустилась задача из метода `AsyncClassTest.runAsyncTask`.
   
   Ниже вывод кода с запуском асинхронной задачи, определенной в другом классе
   ```text
     create async task: main
     runAsyncTask: task-1 id: 39
     internalTask: task-1 id: 39
     external task: task-2 id: 42
   ```
4. Особенность использования аннотации `@Async` в том, что если она используется с методом,
   реализованным в том же классе, что и вызывающий код, то аннотированный ей метод вызывается синхронно.
   Чтобы данная аннотация работала как задумывалось, она должна быть поставлена над методом,
   реализованным в другом классе. Такое требование + требование, чтобы данный метод был публичным,
   необходимы для того, чтобы можно было проксировать вызов метода, помеченного аннотацией `@Async`.
   Прокси обернет метод в `Callable` и засабмиттит задачу на выполнение экзекьютор.
5. Конфигурация по умолчанию следующая
   * емкость очереди - Integer.MAX_VALUE
   * исходное кол-во потоков - 8 (corePoolSize)
   * максимальное кол-во потоков в пуле: Integer.MAX_VALUE
   * можно ли уничтожать простаивающие потоки по истечении времени жизни - да
   * время, жизни простаивающего потока - 60 секунд
   * ждать ли завершения запланированных задач по завершению тред-пула - нет
   * период ожидания завершения запланированных задач - null (не задан) awaitTerminationPeriod
   * префикс имени потока - "task-"
   * кастомайзеры таск-экзекьютора - нет
   * декораторы задач - нет
6. На мой взгляд, значения по умолчанию имеет смысл переопределять в следующих случаях (по убыванию значимости):
   * При большой нагрузке есть риск, что кол-во потоков и очередь вырастут до больших или значений и 
     займут всю память, имеет смысл уменьшать максимальное кол-во потоков в пуле и размер очереди.
     Как гипотетический пример могу привести следующую ситуацию - например, если сервис должен по запросу
     асинхронно взять из БД большое кол-во наборов данных, для каждого набора произвести расчеты и сохранить
     результаты. Если наборов много, то кол-во занятых потоков возрастет, в результате чего, при плохом 
     стечении обстоятельств мы получим OOM. Чтобы этого избежать нужно уменьшить максимальное кол-во потоков
     и ограничить размер очереди.
   * При меняющемся профиле нагрузки, например, когда асинхронные блокирующие задачи чередуются с действиями
     затратными по памяти, имеет смысл уменьшить время жизни потока. Это приведет к более быстрому уничтожению
     простаивающих потоков и освобождению памяти.
   * Если нужно кастомизировать имя потока для более удобного чтения логов, то имеет смысл задать свой 
     узнаваемый префикс.
   * В случае, если нужны более точные мониторинг и логгирование, то стоит добавить свои декораторы задач.
