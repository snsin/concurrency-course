# Задание 2. Теория: очереди #

Дополнительные вопросы по очередям:

1. У LinkedBlockingQueue переменная count хранится в AtomicInteger, а ArrayBlockingQueue использует просто int. Почему?
2. У очередей с приоритетами есть недостаток - задачи с низким приоритетом могут находиться в очереди годами.
   Как можно бороться с такой ситуацией?

#### Ответы ####

1. LinkedBlockingQueue использует два лока - для начала и конца очереди. А размер очереди изменяется и при добавлении
   элемента в начала и при извлечении элемента с конца. Поэтому изменять count могут два потока и если его сделать int,
   то придется синхронизировать эти потоки, а это может привести к потере производительности.
   ArrayBlockingQueue использует один лок, изменение и чтение count происходит при получении блокировки - т.е. всегда
   одним потоком.
2. Вот это сложный вопрос, на мой взгляд. Кажется, что если такая ситуация происходит, это значит, что системе не
   хватает ресурсов для обработки задач. И здесь, на первый взгляд два выхода - добавить ресурсов, либо пересмотреть
   бизнес-логику. Можно, конечно, предложить экзотичные варианты.
   - Попробовать использовать знания о деталях реализации. Например, есть очередь с приоритетами, реализованная
     с помощью двоичной кучи (хотя мне больше нравится перевод пирамида, но прижилось таки куча). Куча, как правило,
     основывается либо на массиве, либо на "массивоподобных" структурах, а значит можно сделать специальный
     обработчик (допустим дополнительнй поток), который будет периодически выбирать задачи из конца массива
     (из-за особенностей реализации кучи в конце как раз находятся задачи с низким приоритетом) и обрабатывать их,
     как-бы в обход очереди.
   - Еще один вариант - ограничить размер очереди, так чтобы она заполнялась полностью задачами и при достижении
     максимального размера блокировать добавление следующих задач до тех пор, пока не выполнятся предыдущие.
   - Вариант основанный на предыдущем - сделать две очереди, которые принимают задачи, при заполнении одной очереди
     переключать прием задач на вторую, а выбирать задачи для исполнения из первой. Как только первая очередь
     опустеет - принимать задачи в нее, а выполнять задачи из второй. Надо правда сказать, что при этом четкая
     система приоритетов пострадает - т.е. может получиться так, что задача с высоким приоритетом выполнится после
     задачи с более низким.
