> 1) В тесте exceptionInOneTask и halfSuccessedTasks 0 раз логгируется "Not all router admins updated their cache",
     > разве там не должно быть другое число?
> 2) Если MountTableRefresherThread больше не поток, лучше переименовать его в таск, например. Ну и лэтч
     > можно выбросить, раз он больше не нужен. Да и реализовывать Runnable больше не нужно:)
> 3) Куда-то пропала запись в лог "Mount table cache refresher was interrupted"
     >
     >     Цель задания - максимально сохранить предыдущий функционал, в том числе запись в логи. Понятно,
     > что в реальной жизни требования не такие строгие, но сейчас это нужно для образовательных целей
> 4) Видно ли сейчас другим потокам обновление поля success в MountTableRefresherThread? Если да, то
     > почему и если нет, то почему?
> 5) Можем ли мы в блоке кода 74-78 упростить код и написать его в виде
     refresher.stream().map(cf::join).toList()?

1. В старом варианте логирование было только в случае таймаута "Not all router admins updated their cache",
   я специально добавлял проверку в тестах, чтобы поведение было таким же. В случае с исключением сделал
   запись в stderr во всех случаях когда это не таймаут, т.к. когда писал тесты на старую версию, заметил,
   что при выбрасывании исключения в stderr ведется запись в каком потоке произошло исключение и его
   (исключения) сообщение.
2. С неймингом да, согласен, даже была такая мысль, но что-то меня остановило, ну вроде такого несколько
   спорного соображения - чтобы было как можно меньше изменений в визуальном представлении.
   Latch видимо просто пропустил. В общем это поправлю.
3. Да это исправлю и попробую протестировать, сходу этого сделать не получилось и что-то я тут не доработал.
4. Обновление поля success может быть "не видно" другим потокам, и даже скорее всего не будет видно,
   из-за того что JMM не обеспечивает для нефинального boolean поля таких гарантий. Ну т.е. чтобы оно
   было видно нужно либо синхронизировать это поле (но тут у нас примитив, поэтому потребуется еще и
   доп-объект синхронизации), либо добавить к ней модификатор volatile. В данном случае я бы выбрал
   volatile, т.к. новое значение поля не вычисляется на основе старого. Поправлю.
5. Тут не совсем понял вопрос, поэтому отвечу на разные варианты
    - а. если речь идет о замене .collect(Collectors.toList())) на .toList(), но при этом подразумевается,
      что в выражении CompletableFuture.allOf(...).join() остается последний join(), то не можем из-за
      версии java в проекте, если поднять версию, то без проблем.
    - б. если имеется в виду можем ли мы убрать .join() от allOf(), то действительно можно упростить.
      Ну т.е. в принципе можно вообще выкинуть allOf, а просто сделать из списка сachedRecords стрим
      из CompletableFuture, сделать на стриме map(cf::join) и потом собрать всё в список.
      Замечание про версию java остается в силе, но думаю в данном случае это не принципиально.
      В общем допилю это дело в исправлении тоже.