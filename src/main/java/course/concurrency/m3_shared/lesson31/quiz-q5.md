# Вопрос 5/5 #

```java
class QuestionFive {

    List<String> list = Collections.synchronizedList(new ArrayList<>());

    public void threadTMethod() {
        String[] values = list.toArray(new String[list.size()]);
        for (String s : values) {
            System.out.println(s);
        }
    }
}
```
Есть переменная list. С ней работают несколько потоков. Поток `Т` выполняет код:

`String[] values = list.toArray(new String[list.size()]);`

Какая ошибка может возникнуть в потоке `Т`?

Исходный код метода toArray
```java
class ArrayList<E> {
    public <T> T[] toArray(T[] a) {
        if (a.length < size)
            // Make a new array of a's runtime type, but my contents:
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }
}
```

Мои соображения следующие:

1. Поскольку `list` - синхронизированный, при вызове `list.toArray(new String[list.size()])` кол-во элементов
   в нем может измениться только с того момента как закончится вызов `list.size()` и только до момента вызова
   `list.toArray(...)`. Предположим, что количество элементов изменилось, в этом случае получаем 2 варианта 
   на входе в `toArray`: кол-во элементов увеличилось и кол-во элементов уменьшилось.
2. Рассмотрим вариант, когда кол-во элементов в списке увеличилось, для конкретики - с 10 до 12. В этом случае
   срабатывает первый `if` в методе `toArray` и в итоге выполняется
   `return (String[]) Arrays.copyOf(elementData, 12, String[].class)`, где `elementData` - внутреннее представление
   списка (в виде массива). В результате, действительно, от исходного массива берется только класс, создается
   новый массив из 12-ти элементов, выполняется копирование двенадцати элементов списка в этот массив, после чего
   новый массив возвращается. Пустых элементов нет (если в самом списке их не было), содержит все элементы из списка,
   исключений не выбрасывается. Т.е. всё ОК, ошибки нет, не наш случай.
3. Рассмотрим вариант, когда кол-во элементов уменьшилось, для конкретики - с 10 до 8. В этом случае выполняется
   `System.arraycopy(elementData, 0, a, 0, 8)`, где `elementData` - внутреннее представление
   списка (в виде массива), `a` - новый массив из десяти пустых элементов. Метод `arraycopy` нативный, код не 
   посмотреть, но судя по его документации, при вызове с данными параметрами произойдет копирование восьми 
   элементов (т.е. всех элементов `list`) из массива `elementData` в массив `a`, при этом типы массивов совпадают,
   кол-во копируемых элементов (8) не больше длины массива-источника (8) и не больше длины массива-приемника (10),
   значит исключений не возникнет. Кол-во копируемых элементов меньше длины массива-приемника, в итоге в нем
   останутся два пустых элемента с индексами 8 и 9. При этом элемент с индексом 8 точно будет равен `null`, т.к.
   выполняется условие `a.length > size`. Наш случай, ответ **Д: В конце массива values будут пустые элементы**
