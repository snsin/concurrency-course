# Задание 4. Практика: synchronized и несколько классов #

Перед вами код двух классов - [ShopStatistic](../../m2_async/executors/spring/sync/ShopStatistics.java)
и [RefundService](../../m2_async/executors/spring/sync/RefundService.java) (с моими небольшими доработками)

#### Вопросы: ####
1. Корректно ли сейчас работает этот код? Можно ли сделать его проще или,
   наоборот, безопаснее? (с многопоточной точки зрения)
2. Допустим, что поддержкой этих классов занимаются разные команды. Что будет, если разработчик ShopStatistics
   поменяет синхронизацию в классе на ReentrantLock?

#### Ответы ####

1. Считаю, что код работает корректно, за исключением того, что в классе RefundService неправильно сбрасывается 
   статистика (т.е. при тех параметрах, что передаются в stat.addData(...), подсчет статистики не всегда будет
   верным, например если до вызова в статистику попало 2 товара по цене 20 и один по 50, а мы делаем возврат одного
   товара по цене 20, то в статистике доход будет 40, а должен быть 70). На мой взгляд можно сделать код проще, убрав
   synchronized у метода RefundService.processRefund, потому что кол-во товаров и цена, которые достаются по id
   корзины - это локальные переменные, их можно не синхронизировать, а синхронизация по классу статистики уже есть
   внутри метода. Также внутри блока synchronized (stat) есть неиспользуемая переменная currentRevenue, которая
   считывается из статистики - ее можно убрать, т.к. рекомендуется в синхронизированных блоках выполнять только
   то что требуется, без лишних действий. Еще (тут правда мне идея подсказала) - синхронизация в классе RefundService
   ведется по не финальному полю, т.е. есть возможность, что ссылка stat изменится, лучше сделать поле финальным.
   Ну и я не большой специалист по спрингу, но, кажется, возможна ситуация, когда в поле stat попадет класс-обертка,
   например, если скоуп ShopStatistic будет не синглтон, а сессионный или, если какой-либо метод ShopStatistic 
   сделать асинхронным (и подозреваю, что еще по куче других причин), и тогда синхронизация в классах RefundService
   и ShopStatistic будет выполняться по разным объектам. Если такое произойдет, то код вряд-ли будет работать корректно. 
2. Если разработчик ShopStatistics поменяет синхронизацию в классе на ReentrantLock, то без доработки RefundService
   код будет некорректным. Т.е. если в RefundService останется синхронизация по полю stat, то очевидно, что
   синхронизация ShopStatistics и RefundService будет производиться по разным объектам. Такая синхронизация будет
   бесполезной, код будет работать неправильно. Т.е. чтобы всё работало корректно, вероятно, разработчик ShopStatistics
   должен будет предоставить механизм, который позволит вызвать методы lock() и unlock() ReentrantLock, 
   используемого в ShopStatistics.

#### Коммент к вопросу 2 (best practice) ####
Хорошо, когда синхронизация - это часть внутренней логики класса. Если другой класс будет полагаться на эти детали 
реализации, и исходный класс однажды поменяется (как в этом примере), то будет очень(!) сложно уловимая ошибка. 
