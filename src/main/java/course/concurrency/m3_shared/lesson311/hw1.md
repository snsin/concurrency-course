# Задание 1 #

Выбрать тип для `course.concurrency.m3_shared.collections.RestaurantService.stat` и реализовать методы
`course.concurrency.m3_shared.collections.RestaurantService.addToStat` и
`course.concurrency.m3_shared.collections.RestaurantService.printStat`, используя только `java.util.concurrent`.
Своих классов делать не надо

> По твоей реализации:
> 1) Думаю, тебе подойдёт метод merge)
> 2) Безопасно ли делать инкремент counter + 1? Если да, то почему и если нет, то почему?
> 3) Рассмотрим альтернативное решение
> ConcurrentHashMap(String, LongAdder)
> Чем оно отличается с точки зрения многопоточности от твоего и чем оно лучше\хуже текущего, на твой взгляд?

#### Ответы ####

1. Реализовал с помощью `LongAdder` и `computeIfAbsent`
2. Ну, собственно тут только посыпать голову пеплом. Конечно же так делать не безопасно, т.к. переменная может
   быть изменена в другом потоке и инкремент происходит не атомарно. Например, может быть такая ситуация, когда
   в одном потоке прочитается одно значение переменной, потом в другом потоке оно увеличится и потом в первом
   потоке 1 добавится к устаревшему значению. После этого это устаревшее значение запишется в map, но также может
   быть перетерто некорректным значением, вычисленным в другом потоке. То что так не произошло при выполнении
   теста - чистая случайность, обусловленная тем, что операция сложения короткая и потоки не помешали друг другу.
   Но, повторюсь, эта чистая случайность, соответственно в других условиях, например, при большей загрузке процессора,
   более медленном процессоре, более длительной операции всё может измениться.
3. Альтернативное решение, во-первых, безопасно с точки зрения многопоточности, а во-вторых, гораздо производительнее.
   Производительнее потому, что при выполнении compute (как было в моей старой реализации) в `map` всегда добавляется
   новое значение, независимо от того было оно до этого или нет, т.е. всегда вызывается метод `put`.
   В ConcurrentHashMap метод `put` реализован так, что значительная часть кода добавления (практически вся) в `map`
   выполняется в `synchronized` секции, а значит при конкуренции потоки вынуждены ожидать освобождения монитора.
   При использовании LongAdder такого не происходит - в случае высокой конкуренции потоки просто выполняют увеличение
   "своей" копии переменной и не ждут друг друга.
