# Задание 1 #

Выбрать тип поля для `stat` для хранения статистики и реализовать методы
`course.concurrency.m3_shared.collections.RestaurantService.addToStat` и
`course.concurrency.m3_shared.collections.RestaurantService.printStat`, используя только `java.util.concurrent`.
Своих классов делать не надо

> По твоей реализации:
> 1) Думаю, тебе подойдёт метод merge)
> 2) Безопасно ли делать инкремент counter + 1? Если да, то почему и если нет, то почему?
> 3) Рассмотрим альтернативное решение
> ConcurrentHashMap(String, LongAdder)
> Чем оно отличается с точки зрения многопоточности от твоего и чем оно лучше\хуже текущего, на твой взгляд?

#### Ответы ####

1. Реализовал с помощью `LongAdder` и `computeIfAbsent`
2. Ну, собственно тут только посыпать голову пеплом. Конечно же так делать не безопасно, т.к. переменная может
   быть изменена в другом потоке и инкремент происходит не атомарно. Например, может быть такая ситуация, когда
   в одном потоке прочитается одно значение переменной, потом в другом потоке оно увеличится и потом в первом
   потоке 1 добавится к устаревшему значению. После этого это устаревшее значение запишется в map, но также может
   быть перетерто некорректным значением, вычисленным в другом потоке. То что так не произошло при выполнении
   теста - чистая случайность, обусловленная тем, что операция сложения короткая и потоки не помешали друг другу.
   Но, повторюсь, эта чистая случайность, соответственно в других условиях, например, при большей загрузке процессора,
   более медленном процессоре, более длительной операции всё может измениться.
3. Альтернативное решение, во-первых, безопасно с точки зрения многопоточности, а во-вторых, гораздо производительнее.
   Производительнее потому, что при выполнении compute (как было в моей старой реализации) в `map` всегда добавляется
   новое значение, независимо от того было оно до этого или нет, т.е. всегда вызывается метод `put`.
   В ConcurrentHashMap метод `put` реализован так, что значительная часть кода добавления (практически вся) в `map`
   выполняется в `synchronized` секции, а значит при конкуренции потоки вынуждены ожидать освобождения монитора.
   При использовании LongAdder такого не происходит - в случае высокой конкуренции потоки просто выполняют увеличение
   "своей" копии переменной и не ждут друг друга.

> Ну подожди, что сразу реализацию-то менять, давай разберёмся, что к чему)
> Но если решил поменять, то метод merge поможет и здесь.
>
> Давай посмотрим на код ConcurrentHashMap, возможно не всё так плохо. Класс всё-таки Concurrent:)
https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java
> Посмотри, как выполняется mappingFunction в методе computeIfAbsent, какие там есть механизмы синхронизации.
> И код класса Node, что есть там.
> Из того, что там используется, можно будет понять, какие операции с многопоточной точки зрения ок, а какие не ок
>
> Сюда мы вернёмся чуть позже, в целом ты всё верно описал, но есть нюанс)

Что касается `merge` - в реализации с `LongAdder` кажется, что это будет сложнее, чем с `computeIfAbsent`, т.к.
внутри `merge` нужно будет делать инкремент и потом возвращать тот же самый LongAdder. При этом в merge
применение `remappingFunction` выполняется в `synchronized` блоке, что убивает преимущества `LongAdder`.
Для наглядности вынес интерфейс `RestaurantService` и сделал две реализации:

- `RestaurantServiceLongAdder` с `computeIfAbsent` и `LongAdder` (выбираю его, как более производительный)
- `RestaurantServiceLong` с `merge` и `Long`

`mappingFunction` в методе `computeIfAbsent` выполняется в `synchronized` блоке, монитором служит специальный
подкласс `Node` - `ReservationNode`. В классе `Node` поле `val` объявлено как `volatile`.
Тут с точки зрения многопоточности вроде ОК, однако это только вычисление отсутствующего значения,
если значение находится, то оно просто выбирается из мапы и возвращается. Значит, если значение в мапе имеется,
то для него выполняются только гарантии `volatile`. Следовательно, использовать такое значение в расчетах, где
следующее значение вычисляется на основе предыдущего небезопасно в многопоточной среде. Для того чтобы это
работало корректно потребуется дополнительная синхронизация или какие-либо другие способы,
например применение `LongAdder`

По поводу нюанса, я кажется понял, видимо я смотрел на дефолтный метод в интерфейсе `Map`, а не на реализацию
в `ConcurrentHashMap`. Функция `compute` выполняется в `synchronized` блоке, если значение есть в мапе.
Этот блок и является узким местом, поэтому если без метода `compute` не обойтись, то производительность
будет падать при высокой конкуренции, как и в случае с `merge`. Но в принципе применять `compute` в
`ConcurrentHashMap` безопасно, т.к. она синхронизирована.