# Задание 3. Практика: анализ кода Spring #

Давайте проникнем в святую святых Spring.
Класс [DefaultSingletonBeanRegistry](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java)
лежит в основе регистрации бинов. Весь класс довольно большой, поэтому изучим небольшие фрагменты кода:

1. Посмотрите на поле disposableBeans и его использование
    - Оптимален ли выбор структуры данных и средств синхронизации для текущего использования? Объясните свой ответ.
2. Посмотрите на поле singletonObjects и его использование
    - а) Какая его задача в этом классе кроме хранения синглтонов?
    - б) Почему у связанных полей singletonFactories и registeredSingletons используется тип HashMap,
      а не ConcurrentHashMap?
3. Посмотрите на метод getSingletonMutex() и комментарий к нему
    - а) В чём опасность такого решения?
    - б) Как можно по-другому решить необходимую задачу?

#### Ответы ####

1. Судя по коду уничтожения всех бинов - метод `destroySingletons()` (строки [515](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L515)-521),
   для коллекции бинов важен порядок, т.к. удаляются бины в порядке, обратном их добавлению. Вероятно это
   связано с тем, что регистрируемый новый бин может зависеть от предыдущих, поэтому уничтожение должно производиться
   в обратном порядке - самым первым уничтожается последний зарегистрированный. В связи с этим выбор `LinkedHashMap`
   и дополнительная синхронизация являются оправданными, т.к. `ConcurrentHashMap` не обладает свойством упорядоченности
   ключей, а `ConcurrentSkipListMap` упорядочивает ключи не в порядке добавления, а на основании сравнения ключей -
   либо в "натуральном порядке", либо с помощью заданного в конструкторе компаратора.
2. `singletonObjects`
   - a) Кроме хранения синглтонов, по монитору объекта (мапы) `singletonObjects` выполняется синхронизация
     в различных методах, например при регистрации, добавлении, удалении, уничтожении синглтонов.
   - б) У связанных полей `singletonFactories` и `registeredSingletons` используется тип `HashMap`,
     а не `ConcurrentHashMap`, т.к. работа с этими коллекциями синхронизируется по монитору `singletonObjects`,
     то использование потокобезопасной `ConcurrentHashMap` нецелесообразно.
3. `getSingletonMutex()`
   - а) В первую очередь, опасность такого решения как раз в том, что указано в комментарии - неправильное использование
     может привести к дедлокам. Дополнительно, опасность данного решения, на мой взгляд, в том, что открывается ссылка
     на мапу (словарь) синглтонов, которую из-за неосторожности или незнания могут использовать не только для
     синхронизации, но и для изменения мапы синглтонов. Например, можно случайно удалить все синглтоны из мапы,
     что наверняка приведет к катастрофическим последствиям само по себе, но дополнительно синглтоны не удалятся
     из связанных коллекций/мап, что усугубит ситуацию. Если подводить итог, у такого решения два основных недостатка:
     чтобы правильно воспользоваться классом нужно знать детали реализации; раскрывается внутренне устройство класса
     (не уверен на 100%, но кажется это можно назвать нарушением инкапсуляции).
   - б) Поскольку я полностью не изучил код `DefaultSingletonBeanRegistry` и плохо себе представляю как он используется,
     мне сложно сказать наверняка. Мне видится один вариант: использовать для синхронизации отдельный неизменяемый
     объект, на который было бы более безопасно отдать ссылку. Например, добавить в класс финальное поле
     `private final Object mutex = new Object();` и использовать его для синхронизации. Еще лучше - скрыть детали
     реализации, а конкретно синхронизацию, от пользователя, но здесь я не знаю возможно ли это без слишком затратных
     доработок и мне сложно предложить конкретный способ.

> Здесь тоже всё ок, но обращу твоё внимание, что в disposableBeans сейчас используются только ключи.
> По сути мы просто запоминаем порядок добавления бинов. Какая структура данных может тоже решить эту задачу?
> И получится ли с ней избавиться от текущих блоков synchronized?

По поводу того, что в disposableBeans используются только ключи - не соглашусь. 
В методе `org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton`
в строке [557](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L557)
`disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);` удаляется бин
из мапы, но при этом его значение возвращается и используется далее в методе `destroyBean(beanName, disposableBean)`
и в этом методе вызывается метод `bean.destroy()` при условии, что `bean != null`. Не уверен, что если `bean` будет
`null` всегда, т.е. мы просто никогда не будем вызывать `destroy()`, то это никак не отразится на работе,
ну а точнее на завершении, приложения.

Если же принять, что нужны только имена бинов, то пожалуй можно использовать структуру 
`CopyOnWriteArrayList<String> disposableBeanNameList` при этом в коде `DefaultSingletonBeanRegistry` от `synchronized`
получится избавиться в методах `registerDisposableBean(/*...*/)` и `destroySingleton(/*...*/)`, но по сути внутри
структуры `CopyOnWriteArrayList` всё-равно используются `synchronized`. В методе `destroySingletons` можно будет
вместо строк 515 - 518 сделать  `String[] disposableBeanNames = disposableBeanNameList.toArray(new String[0])`,
но с небольшим эффектом: в текущей реализации во время копирования ключей `disposableBeans` в массив,
в `disposableBeans` нельзя добавить новые элементы, а в случае предложенного решения - будет можно.
Насколько это критично сказать сложно, но соображения есть следующие - в текущей реализации в строках 519 - 521
происходит обход массива, начиная с последнего элемента и уничтожение синглтона по имени. В это время в
`disposableBeans` также можно добавить новые значения, поэтому с точки зрения критичности, на мой взгляд,
текущий вариант и предложенный - приблизительно равнозначны.

Ссылка [DefaultSingletonBeanRegistry:515](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L515)
