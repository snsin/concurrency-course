# Задание 3. Практика: анализ кода Spring #

Давайте проникнем в святую святых Spring.
Класс [DefaultSingletonBeanRegistry](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java)
лежит в основе регистрации бинов. Весь класс довольно большой, поэтому изучим небольшие фрагменты кода:

1. Посмотрите на поле disposableBeans и его использование
    - Оптимален ли выбор структуры данных и средств синхронизации для текущего использования? Объясните свой ответ.
2. Посмотрите на поле singletonObjects и его использование
    - а) Какая его задача в этом классе кроме хранения синглтонов?
    - б) Почему у связанных полей singletonFactories и registeredSingletons используется тип HashMap,
      а не ConcurrentHashMap?
3. Посмотрите на метод getSingletonMutex() и комментарий к нему
    - а) В чём опасность такого решения?
    - б) Как можно по-другому решить необходимую задачу?

#### Ответы ####

1. Судя по коду уничтожения всех бинов - метод `destroySingletons()` (строки [515](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-beans/src/main/java/org/springframework/beans/factory/support/DefaultSingletonBeanRegistry.java#L515)-521),
   для коллекции бинов важен порядок, т.к. удаляются бины в порядке, обратном их добавлению. Вероятно это
   связано с тем, что регистрируемый новый бин может зависеть от предыдущих, поэтому уничтожение должно производиться
   в обратном порядке - самым первым уничтожается последний зарегистрированный. В связи с этим выбор `LinkedHashMap`
   и дополнительная синхронизация являются оправданными, т.к. `ConcurrentHashMap` не обладает свойством упорядоченности
   ключей, а `ConcurrentSkipListMap` упорядочивает ключи не в порядке добавления, а на основании сравнения ключей -
   либо в "натуральном порядке", либо с помощью заданного в конструкторе компаратора.
2. `singletonObjects`
   - a) Кроме хранения синглтонов, по монитору объекта (мапы) `singletonObjects` выполняется синхронизация
     в различных методах, например при регистрации, добавлении, удалении, уничтожении синглтонов.
   - б) У связанных полей `singletonFactories` и `registeredSingletons` используется тип `HashMap`,
     а не `ConcurrentHashMap`, т.к. работа с этими коллекциями синхронизируется по монитору `singletonObjects`,
     то использование потокобезопасной `ConcurrentHashMap` нецелесообразно.
3. `getSingletonMutex()`
   - а) В первую очередь, опасность такого решения как раз в том, что указано в комментарии - неправильное использование
     может привести к дедлокам. Дополнительно, опасность данного решения, на мой взгляд, в том, что открывается ссылка
     на мапу (словарь) синглтонов, которую из-за неосторожности или незнания могут использовать не только для
     синхронизации, но и для изменения мапы синглтонов. Например, можно случайно удалить все синглтоны из мапы,
     что наверняка приведет к катастрофическим последствиям само по себе, но дополнительно синглтоны не удалятся
     из связанных коллекций/мап, что усугубит ситуацию. Если подводить итог, у такого решения два основных недостатка:
     чтобы правильно воспользоваться классом нужно знать детали реализации; раскрывается внутренне устройство класса
     (не уверен на 100%, но кажется это можно назвать нарушением инкапсуляции).
   - б) Поскольку я полностью не изучил код `DefaultSingletonBeanRegistry` и плохо себе представляю как он используется,
     мне сложно сказать наверняка. Мне видится один вариант: использовать для синхронизации отдельный неизменяемый
     объект, на который было бы более безопасно отдать ссылку. Например, добавить в класс финальное поле
     `private final Object mutex = new Object();` и использовать его для синхронизации. Еще лучше - скрыть детали
     реализации, а конкретно синхронизацию, от пользователя, но здесь я не знаю возможно ли это без слишком затратных
     доработок и мне сложно предложить конкретный способ.
