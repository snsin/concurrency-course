# Задание 2. Практика: анализ использования CountDownLatch #

Класс [KafkaExactlyOnceDemo](https://github.com/apache/kafka/blob/99b9b3e84f4e98c3f07714e1de6a139a004cbc5b/examples/src/main/java/kafka/examples/KafkaExactlyOnceDemo.java)
показывает один из сценариев работы с классами Apache Kafka.

Посмотрите на использование `CountDownLatch` в методе `main`.

#### Вопросы: ####

1. Какую задачу выполняет `CountDownLatch`?
2. Какой другой инструмент может сделать то же самое, но без блокировки потоков?
3. Пусть ответ на предыдущий вопрос - это Х. Что лучше для таких демо классов и 
   интеграционных тестов - CountDownLatch или X? Почему?


#### Ответы ####
1. В данном случае `CountDownLatch` применяется для того чтобы определенные этапы примера
   выполнялись последовательно:
   - инициализация продьюсера;
   - обработка сообщений;
   - верификация того, что сообщения отправились точно один раз.
2. Считаю, что другим инструментом может быть `CompletableFuture`, он позволит сделать 
   всё то же самое и избежать блокировки потоков.
3. Для демо-классов и интеграционных тестов считаю лучшим вариантом `CountDownLatch`.
   На мой взгляд для интеграционных тестов и демо примеров простота, читаемость и понятность
   имеют приоритет над производительностью, и код написанный с применением `CountDownLatch`
   как раз обладает этими преимуществами по сравнению с использованием `CompletableFuture`.
   А более низкая производительность кода с `CountDownLatch` в данном случае не существенна.




