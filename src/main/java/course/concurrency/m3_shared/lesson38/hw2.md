# Задание 4. Практика: анализ кода SimpleDateFormat #

Теперь изучим класс [SimpleDateFormat](https://github.com/openjdk/jdk11u/blob/73eef16128417f4a489c4dde47383bb4a00f39d4/src/java.base/share/classes/java/text/SimpleDateFormat.java). Два общеизвестных факта:

- В многопоточной среде для него нужен ThreadLocal
- В java 8 появилась потокобезопасная альтернатива DateTimeFormatter

Но давайте разберёмся подробнее. Подсмотрите на код класса и напишите:

1. Почему экземпляры класса нельзя использовать как локальные переменные?
2. Почему экземпляры класса небезопасны в многопоточной среде?

#### Ответы ####

1. Думаю потому, что при конструировании экземпляра класса выполняется "тяжелая" операция компилирования
   шаблона. Если создавать локальные переменные на каждый случай форматирования даты, то и шаблон будет
   компилироваться каждый раз, что будет достаточно затратно, особенно если учесть, что форматирование даты
   скорее всего будет выполняться достаточно часто.
2. Экземпляры класса небезопасны в многопоточной среде, т.к. поля класса не финальные (и даже не volatile)
   и мутабельные, методы не синхронизированы. В методах выполняется присваивание значений полям класса, 
   например в приватном методе `SimpleDateFormat.checkNegativeNumberExpression`, который вызывается из 
   публичного метода `SimpleDateFormat.parse`, могут присваиваться либо поля `hasFollowingMinusSign`,
   `minusSign` либо поле `originalNumberFormat`, от которых в итоге зависит результат парсинга.
   В многопоточной среде эти поля могут быть изменены из разных потоков, значит результат парсинга будет
   зависеть от порядка выполнения потоков. В итоге результат будет некорректным.
