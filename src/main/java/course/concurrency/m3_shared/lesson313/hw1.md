# Задание 2. Практика: анализ кода #

Посмотрите код
класса [SimpleAnnotationMetadata](https://github.com/spring-projects/spring-framework/blob/b595dc1dfad9db534ca7b9e8f46bb9926b88ab5a/spring-core/src/main/java/org/springframework/core/type/classreading/SimpleAnnotationMetadata.java).
Включите бдительность на максимум.

Какие поля и в каких ситуациях могут измениться?

#### Ответ ####

В данном классе заметил единственное "подозрительное" поле - это `annotationTypes`. Проблему я вижу
в том, что данное поле является ссылкой, не помечено как `volatile`, не синхронизировано и имеет ленивую
инициализацию - похоже на поле `hash` в классе `String`, правда там это всё-таки примитив. Проблемы могут
возникнуть если метод`getAnnotationTypes()` вызывается в многопоточной среде и разные потоки прочитают
`annotationTypes` как null. В этом случае "победит" поток, который запишет данное поле последним.

Написал код [MutationExample](./MutationExample.java) (насколько это корректный код - не знаю, буду благодарен
за ревью), иллюстрирующий данное поведение, в итоге у меня получился примерно такой вывод. Запускал одновременно
16 потоков, в каждом вызывал метод `getAnnotationTypes()` - каждый поток вернул свою ссылку. Если метод
`getAnnotationTypes()` сделать `synchronized`, то разные потоки возвращают одну и ту же ссылку.
Единственное, поскольку класс не публичный, а копию в другом пакете не хочется закидывать в репозиторий, код не
скомпилируется, если его просто клонировать из репозитория. Чтобы всё было ОК нужно положить копию исходного
кода класса в текущий пакет.

```text
   1:   1109371569 != 728890494
   2:    728890494 != 1768305536
   3:   1768305536 != 1530388690
   4:   1530388690 != 1146743572
   5:   1146743572 != 1512981843
   6:   1512981843 != 42768293
   7:     42768293 != 1717159510
   8:   1717159510 != 1834188994
   9:   1834188994 != 1174361318
  10:   1174361318 != 589873731
  11:    589873731 != 200006406
  12:    200006406 != 2052001577
  13:   2052001577 != 1160264930
  14:   1160264930 != 544724190
  15:    544724190 != 1972439101

last reference index    3: @1530388690
```

> Единственное, что я бы упростила проверку результата. Если в сете больше одного элемента,
> значит какие-то вызовы вернули разные ссылки

В данном случае проверить как ты предложила не получится. В методе `getAnnotationTypes()` класса
`SimpleAnnotationMetadata`вызывается `AnnotationMetadata.super.getAnnotationTypes()` а он в свою очередь
создает новое множество (по крайней мере в моем примере), которое потом оборачивается в неизменяемое
множество. В данном случае множество возвращается всегда пустое, однако, как мы видим, на самом деле
это разные множества т.к. в `AnnotationMetadata.super.getAnnotationTypes()` создается новое множество
`LinkedHashSet`, а не возвращается `Set.of()` или `Collections.emptySet()`. Принципиально скорее всего
разницы нет, особенно в случае пустого множества, однако, с точки зрения неизменяемости объекта это
нарушение неизменяемости. И это на мой взгляд отличается от ситуации с полем `hash` в классе `String`, т.к.
hash это примитив - у него нет "идентичности", точнее его значение и есть его идентичность. А вот со
ссылочными типами по-другому, в данном случае пустые множества эквивалентны друг другу, но не идентичны.

> Но это ещё не всё, попробуй изучить момент создания объекта SimpleAnnotationMetadata

Да, похоже я что-то в глубину копнул, а более очевидные вещи - пропустил (слона-то я и не заметил :)),
как говорится). В качестве аргументов конструктор класса принимает массивы, а это значит, что их можно
изменить "снаружи" при наличии ссылки. Т.е. если доступна ссылка на эти массивы, то можно поменять их
элементы и тем самым изменятся поля внутри класса. Написал небольшой
пример: [ArrayMutationExample](./ArrayMutationExample.java)

Это поля:

- `private final String[] interfaceNames;`
- `private final String[] memberClassNames;`
- `private final MethodMetadata[] annotatedMethods;`
